#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 8 0 32
    bytecblock "batch_records" "total_batches" "authorized" 0x151f7c75 "batch_assets"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/supply_chain_tracer/contract.py:6-7
    // # Track total registered batches
    // self.total_batches = GlobalState(UInt64(0))
    bytec_1 // "total_batches"
    intc_2 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/supply_chain_tracer/contract.py:4
    // class SupplyChainTracer(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@16
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x73bc6501 0x23831597 0x71f02579 0x36a19335 0xdb6e0102 0x9ce0452d 0x46fb9373 // method "authorize(address)void", method "revoke(address)void", method "register_batch(byte[])uint64", method "link_asset(uint64,uint64)void", method "record_event(uint64,byte[])void", method "get_batch_record(uint64)byte[]", method "get_asset_for_batch(uint64)uint64"
    txna ApplicationArgs 0
    match authorize revoke register_batch link_asset record_event get_batch_record get_asset_for_batch
    err

main___algopy_default_create@16:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_0 // 1
    return


// smart_contracts.supply_chain_tracer.contract.SupplyChainTracer.authorize[routing]() -> void:
authorize:
    // smart_contracts/supply_chain_tracer/contract.py:22
    // @abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/supply_chain_tracer/contract.py:28
    // assert Txn.sender == Global.creator_address, "Only creator can authorize"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can authorize
    // smart_contracts/supply_chain_tracer/contract.py:29
    // self.authorized[account] = UInt64(1)
    bytec_2 // "authorized"
    swap
    concat
    intc_0 // 1
    itob
    box_put
    // smart_contracts/supply_chain_tracer/contract.py:22
    // @abimethod
    intc_0 // 1
    return


// smart_contracts.supply_chain_tracer.contract.SupplyChainTracer.revoke[routing]() -> void:
revoke:
    // smart_contracts/supply_chain_tracer/contract.py:31
    // @abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/supply_chain_tracer/contract.py:36
    // assert Txn.sender == Global.creator_address, "Only creator can revoke"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can revoke
    // smart_contracts/supply_chain_tracer/contract.py:38
    // balance, admin = self.authorized.maybe(account)
    bytec_2 // "authorized"
    swap
    concat
    dup
    box_len
    bury 1
    // smart_contracts/supply_chain_tracer/contract.py:39
    // assert admin, "Account not authorized"
    assert // Account not authorized
    // smart_contracts/supply_chain_tracer/contract.py:41
    // del self.authorized[account]
    box_del
    pop
    // smart_contracts/supply_chain_tracer/contract.py:31
    // @abimethod
    intc_0 // 1
    return


// smart_contracts.supply_chain_tracer.contract.SupplyChainTracer.register_batch[routing]() -> void:
register_batch:
    // smart_contracts/supply_chain_tracer/contract.py:47
    // @abimethod
    txna ApplicationArgs 1
    dup
    intc_2 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/supply_chain_tracer/contract.py:53
    // assert Txn.sender == Global.creator_address, "Only creator can register batches"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can register batches
    // smart_contracts/supply_chain_tracer/contract.py:54
    // batch_id = self.total_batches.value + UInt64(1)
    intc_2 // 0
    bytec_1 // "total_batches"
    app_global_get_ex
    assert // check self.total_batches exists
    intc_0 // 1
    +
    // smart_contracts/supply_chain_tracer/contract.py:55
    // self.batch_records[batch_id] = first_record
    dup
    itob
    bytec_0 // "batch_records"
    dig 1
    concat
    dup
    box_del
    pop
    uncover 3
    box_put
    // smart_contracts/supply_chain_tracer/contract.py:56
    // self.total_batches.value = batch_id
    bytec_1 // "total_batches"
    uncover 2
    app_global_put
    // smart_contracts/supply_chain_tracer/contract.py:47
    // @abimethod
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.supply_chain_tracer.contract.SupplyChainTracer.link_asset[routing]() -> void:
link_asset:
    // smart_contracts/supply_chain_tracer/contract.py:59
    // @abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/supply_chain_tracer/contract.py:65
    // assert Txn.sender == Global.creator_address, "Only creator can link assets"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can link assets
    // smart_contracts/supply_chain_tracer/contract.py:67
    // id, exists = self.batch_records.maybe(batch_id)
    swap
    itob
    bytec_0 // "batch_records"
    dig 1
    concat
    box_len
    bury 1
    // smart_contracts/supply_chain_tracer/contract.py:68
    // assert exists, "Batch not found"
    assert // Batch not found
    // smart_contracts/supply_chain_tracer/contract.py:70
    // self.batch_assets[batch_id] = asset_id
    bytec 4 // "batch_assets"
    swap
    concat
    swap
    itob
    box_put
    // smart_contracts/supply_chain_tracer/contract.py:59
    // @abimethod
    intc_0 // 1
    return


// smart_contracts.supply_chain_tracer.contract.SupplyChainTracer.record_event[routing]() -> void:
record_event:
    // smart_contracts/supply_chain_tracer/contract.py:72
    // @abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_2 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/supply_chain_tracer/contract.py:78
    // balance, admin = self.authorized.maybe(Txn.sender)
    bytec_2 // "authorized"
    txn Sender
    concat
    box_len
    bury 1
    // smart_contracts/supply_chain_tracer/contract.py:79
    // assert admin, "Unauthorized participant"
    assert // Unauthorized participant
    // smart_contracts/supply_chain_tracer/contract.py:81
    // old_data, exists = self.batch_records.maybe(batch_id)
    swap
    itob
    bytec_0 // "batch_records"
    dig 1
    concat
    dup
    box_get
    // smart_contracts/supply_chain_tracer/contract.py:82
    // assert exists, "Batch not found"
    assert // Batch not found
    // smart_contracts/supply_chain_tracer/contract.py:84
    // asset_id, asset_linked = self.batch_assets.maybe(batch_id)
    bytec 4 // "batch_assets"
    uncover 3
    concat
    box_len
    bury 1
    // smart_contracts/supply_chain_tracer/contract.py:85
    // assert asset_linked, "No asset linked to this batch"
    assert // No asset linked to this batch
    // smart_contracts/supply_chain_tracer/contract.py:87-88
    // # Concatenate new data to existing record string
    // combined = old_data + b" | " + new_data
    pushbytes 0x207c20
    concat
    uncover 2
    concat
    // smart_contracts/supply_chain_tracer/contract.py:89
    // self.batch_records[batch_id] = combined
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/supply_chain_tracer/contract.py:72
    // @abimethod
    intc_0 // 1
    return


// smart_contracts.supply_chain_tracer.contract.SupplyChainTracer.get_batch_record[routing]() -> void:
get_batch_record:
    // smart_contracts/supply_chain_tracer/contract.py:95
    // @abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/supply_chain_tracer/contract.py:100
    // record, exists = self.batch_records.maybe(batch_id)
    itob
    bytec_0 // "batch_records"
    swap
    concat
    box_get
    // smart_contracts/supply_chain_tracer/contract.py:101
    // assert exists, "Batch not found"
    assert // Batch not found
    // smart_contracts/supply_chain_tracer/contract.py:95
    // @abimethod
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.supply_chain_tracer.contract.SupplyChainTracer.get_asset_for_batch[routing]() -> void:
get_asset_for_batch:
    // smart_contracts/supply_chain_tracer/contract.py:104
    // @abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/supply_chain_tracer/contract.py:109
    // asset_id, exists = self.batch_assets.maybe(batch_id)
    itob
    bytec 4 // "batch_assets"
    swap
    concat
    box_get
    swap
    btoi
    // smart_contracts/supply_chain_tracer/contract.py:110
    // assert exists, "No asset linked to this batch"
    swap
    assert // No asset linked to this batch
    // smart_contracts/supply_chain_tracer/contract.py:104
    // @abimethod
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return
