#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 0 32 2
    bytecblock "total_batches" "batch_records" "authorized" 0x151f7c75
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/supply_chain_tracer/contract.py:6-7
    // # Track total registered batches
    // self.total_batches = GlobalState(UInt64(0))
    bytec_0 // "total_batches"
    intc_1 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/supply_chain_tracer/contract.py:4
    // class SupplyChainTracer(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@14
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x73bc6501 0x23831597 0x71f02579 0xdb6e0102 0x9ce0452d // method "authorize(address)void", method "revoke(address)void", method "register_batch(byte[])uint64", method "record_event(uint64,byte[])void", method "get_batch_record(uint64)byte[]"
    txna ApplicationArgs 0
    match authorize revoke register_batch record_event get_batch_record
    err

main___algopy_default_create@14:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_0 // 1
    return


// smart_contracts.supply_chain_tracer.contract.SupplyChainTracer.authorize[routing]() -> void:
authorize:
    // smart_contracts/supply_chain_tracer/contract.py:17
    // @abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/supply_chain_tracer/contract.py:23
    // assert Txn.sender == Global.creator_address, "Only creator can authorize"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can authorize
    // smart_contracts/supply_chain_tracer/contract.py:24
    // self.authorized[account] = UInt64(1)
    bytec_2 // "authorized"
    swap
    concat
    intc_0 // 1
    itob
    box_put
    // smart_contracts/supply_chain_tracer/contract.py:17
    // @abimethod
    intc_0 // 1
    return


// smart_contracts.supply_chain_tracer.contract.SupplyChainTracer.revoke[routing]() -> void:
revoke:
    // smart_contracts/supply_chain_tracer/contract.py:26
    // @abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/supply_chain_tracer/contract.py:31
    // assert Txn.sender == Global.creator_address, "Only creator can revoke"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can revoke
    // smart_contracts/supply_chain_tracer/contract.py:32
    // del self.authorized[account]
    bytec_2 // "authorized"
    swap
    concat
    box_del
    pop
    // smart_contracts/supply_chain_tracer/contract.py:26
    // @abimethod
    intc_0 // 1
    return


// smart_contracts.supply_chain_tracer.contract.SupplyChainTracer.register_batch[routing]() -> void:
register_batch:
    // smart_contracts/supply_chain_tracer/contract.py:38
    // @abimethod
    txna ApplicationArgs 1
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/supply_chain_tracer/contract.py:44
    // assert Txn.sender == Global.creator_address, "Only creator can register batches"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can register batches
    // smart_contracts/supply_chain_tracer/contract.py:46
    // batch_id = self.total_batches.value + UInt64(1)
    intc_1 // 0
    bytec_0 // "total_batches"
    app_global_get_ex
    assert // check self.total_batches exists
    intc_0 // 1
    +
    // smart_contracts/supply_chain_tracer/contract.py:47
    // self.batch_records[batch_id] = first_record
    dup
    itob
    bytec_1 // "batch_records"
    dig 1
    concat
    dup
    box_del
    pop
    uncover 3
    box_put
    // smart_contracts/supply_chain_tracer/contract.py:48
    // self.total_batches.value = batch_id
    bytec_0 // "total_batches"
    uncover 2
    app_global_put
    // smart_contracts/supply_chain_tracer/contract.py:38
    // @abimethod
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.supply_chain_tracer.contract.SupplyChainTracer.record_event[routing]() -> void:
record_event:
    // smart_contracts/supply_chain_tracer/contract.py:51
    // @abimethod
    txna ApplicationArgs 1
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/supply_chain_tracer/contract.py:58
    // old_data, exists = self.batch_records.maybe(batch_id)
    swap
    itob
    bytec_1 // "batch_records"
    swap
    concat
    dup
    box_get
    // smart_contracts/supply_chain_tracer/contract.py:59
    // assert exists, "Batch not found"
    assert // Batch not found
    // smart_contracts/supply_chain_tracer/contract.py:61-62
    // # Concatenate new data to existing record string
    // combined = old_data + Bytes(b" | ") + new_data
    pushbytes 0x207c20
    concat
    uncover 2
    concat
    // smart_contracts/supply_chain_tracer/contract.py:63
    // self.batch_records[batch_id] = combined
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/supply_chain_tracer/contract.py:51
    // @abimethod
    intc_0 // 1
    return


// smart_contracts.supply_chain_tracer.contract.SupplyChainTracer.get_batch_record[routing]() -> void:
get_batch_record:
    // smart_contracts/supply_chain_tracer/contract.py:69
    // @abimethod
    txna ApplicationArgs 1
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/supply_chain_tracer/contract.py:74
    // record, exists = self.batch_records.maybe(batch_id)
    itob
    bytec_1 // "batch_records"
    swap
    concat
    box_get
    // smart_contracts/supply_chain_tracer/contract.py:75
    // assert exists, "Batch not found"
    assert // Batch not found
    // smart_contracts/supply_chain_tracer/contract.py:69
    // @abimethod
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return
